# 개요

[링크](https://www.notion.so/JS-100-2-327372e894a843cf9c9430070c1ce5da)
에서 나온 문제를 풀어보고 있다.
초급 문제이다!

다음에는 여기 강의 들어야지
[인프런](https://www.inflearn.com/pages/prepare-coding-test)

- {날짜 : 21.03.04~05, 공부내역 : 'Q51 ~ Q53'}
- {날짜 : 21.03.05, 공부내역 : 'Q53 ~ '}

# 복습 리스트

- [merge-sort](#merge-sort-공부)
- [quick sort](#문제-52-quick-sort)
- [balanced brackets](#53-괄호-문자열)

# 문풀

## 문51. merge sort

### merge sort 공부

- 병합정렬은 대표적인 정렬 알고리즘 중 하나
- 리스트 길이가 0 or 1이면 이미 정렬된 것.
- 길이가 그 이상이면, 정렬되지 않은 리스트의 절반을 잘라, 비슷한 크기로 나눈다
- 각 리스트를 또 비교하여 병합정렬을 이용해 정렬한다. (반복)
- 두개 리스트를 하나의 정렬된 리스트로 합친다.

[참고](https://reactgo.com/merge-sort-algorithm-javascript/)

#### 순서

1. [3, 4] [2, 1]
   - 둘로 나눈 뒤 가장 작은 chunk로 나눈다.
2. [3][4] [2][1]
3. 나눈 chunk들을 정렬하여 합친다.
   - [3, 4] [1, 2]
4. index 0 을 각각 비교했을 때, 1이 3보다 작으므로 따로 빼준다.
   - [3, 4] [2]
   - **sorted array**: [1]
5. 다시 index 0을 각각 비교하여 따로 빼준다
   - [3,4] [ ]
   - **sorted array**: [1, 2]
6. **하나의 어레이가 공백이 됐으므로 이제 합친다.**
   - [1, 2, 3, 4]

#### 실전 코드

```js
function merger(left, right) {
  // arr = sorted array
  const arr = [];
  while (left.length && right.length) {
    if (left[0] < right[0]) {
      // array의 첫번째 요소를 비교하여
      // 그중 작은 첫번째 요소를 빼낸뒤
      // sortedArray인 arr에 넣는다
      arr.push(left.shift());
    } else {
      arr.push(right.shift());
    }
  }
  return [...arr, ...left, ...right];
}

const mergeSort = (array) => {
  let half = array.length / 2;

  if (array.length < 2) {
    return array;
  }

  const left = array.splice(0, half);

  return merger(mergeSort(left), mergeSort(array));
};

const arr = [10, 2, 28, 3, 1, 9, 8, 23];
console.log(mergeSort(arr));
```

## 문제 52. quick sort

### 공부: quick sort

[참고](https://reactgo.com/quicksort-algorithm-javascript/)

- 큰 데이터일 때 merge sort나 heap sort보다 효과적인 sorting algorithm 임

#### 순서

1. 먼저 pivot (중심점)이 될만한 value를 해당 배열에서 찾는다. 아무거나 가능하다.
2. 배열을 돌면서 pivot보다 작은건 left, 큰건 right으로 나눠준다.
3. 재귀적으로 **right 부분(pivot보다 큰 파트)을 반복**한다.

#### 실전 코드

```js
const quickSort = (array) => {
  // 기초 부분
  if (array.length < 2) {
    return array;
  }

  // pivot은 아무것이나 가능하다.
  const pivot = array[array.length - 1];
  let left = [];
  let right = [];

  const len = array.length - 1;

  let index = 0;
  while (index < len) {
    if (array[index] < pivot) {
      left.push(array[index]);
    } else {
      right.push(array[index]);
    }
    index++;
  }

  // 재귀로 반복해줘야한다
  return [...quickSort(left), pivot, ...quickSort(right)];
  // pivot은 이렇게 따로 둠으로써,
  // 매번 재귀를 할때 마다 해당하는 pivot이 새로운 숫자가 된다!
};

const arr = [10, 2, 28, 3, 1, 9, 8, 23];
console.log(quickSort(arr));
```

## 53. 괄호 문자열

- `()`
- `{}`
- `[]`
- 와 같이 짝이 맞을 때 YES
- `())`, `[[]`, `{})`
- 처럼 짝이 맞지 않을 때 No 를 리턴

### 풀이

```js
const guessing = (string) => {
  let brackets = string.split('');
  let count = 0;

  // 일단 짝이 맞는지 확인한다 '0'이면 짝이 맞는 것
  for (let i = 0; i < brackets.length; i++) {
    if (brackets[i] === '(') {
      count++;
    }
    if (brackets[i] === ')') {
      count--;
    }
  }

  if (count !== 0) {
    return false;
  }

  // 이것도 짝이 맞는지 확인하는 방법 2
  let arrayForCheck = [];
  for (let i in brackets) {
    if (brackets[i] === '(') {
      arrayForCheck.push('(');
    }
    if (brackets[i] === ')') {
      if (bracket.length === 0) {
        return false;
      }
      arrayForCheck.pop();
    }
  }
  return true;
};

const str = '((())))';
console.log(guessing(str));
```

### 공부 balanced brackets in javascript

#### 방법 1.

```js
const guessing = (str) => {
  if (str.length < 2) {
    return false;
  }

  let matchingOpeningBracket;
  let c;
  let stack = [];

  let openingBrackets = ['[', '{', '('];
  let closingBrackets = [']', '}', ')'];

  for (let i = 0; i < str.length; i++) {
    c = str[i];

    //  c가 closing 이라면
    if (closingBrackets.indexOf(c) > -1) {
      // matching 할당 : c의 괄호 스타일(소.중.대) 가 맞는지 확인해보기 위해
      // 같은 스타일의 오프닝을 matcing에 넣는다
      matchingOpeningBracket = openingBrackets[closingBrackets.indexOf(c)];
      // closing이 있는데 stack은 없다? 그럼 false
      // 가장 처음에 넣은 stack과 string의 제일 마지막의 closing을 비교해서 아니다? false
      if (stack.length == 0 || stack.pop() != matchingOpeningBracket) {
        return false;
      }
    } else {
      // c가 opening이라면
      // stack에 opening 을 넣음
      stack.push(c);
    }
  }

  return stack.length == 0;
};

const str = '((({}){))';
console.log(guessing(str));
```

#### 방법2. - 새로운 자료구조인 map을 사용한

##### Map 공부

- ES6에서 소개된 **새로운 자료구조인 Map**을 사용한다
- [mdn map 참고](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map)
- Map 객체는 키-값 쌍을 저장하며 각 쌍의 삽입 순서도 기억하는 콜렉션입니다. 아무 값(객체와 원시 값)이라도 키와 값으로 사용할 수 있습니다.
- 명시적으로 제공한 키 외에 어떠한 키도 없음 (의도치 않은 키 없음)
- Map의 키는 함수, 객체 등을 포함한 모든 키 가능
  - Object는 string 또는 symbol이어야함
- Map의 키는 정렬이 가능함. 순회는 삽입 순으로 이뤄짐
  - Object는 정렬되지 않음
- Map.prototype.size를 통해 쉽게 항목수를 알아 낼 수 있음
- Map은 순회가능 하므로 바로 순회 할 수 있음.
  - Object를 순회하려면 먼저 모든 키를 알아낸 후, 그 키의 배열을 순회해야 합니다.
- 잦은 키-값 쌍의 추가와 제거에서 더 좋은 성능을 보임.

```js
function braces(values) {
  let i;
  let result = [];
  let len = values.length;

  for (i = 0; i < len; i++) {
    if (isBalanced(values[i])) {
      result.push('YES');
    } else {
      result.push('NO');
    }
  }
  return result;
}

function isBalanced(str) {
  let i, ch;

  let bracketsMap = new Map();
  // closing으로 검색할 것이므로 key가 closing이 되어야함
  bracketsMap.set(']', '[');
  bracketsMap.set('}', '{');
  bracketsMap.set(')', '(');
  let closingBrackets = [...bracketsMap.keys()];
  let openingBrackets = [...bracketsMap.values()];

  let temp = [];
  let len = str.length;

  for (i = 0; i < len; i++) {
    ch = str[i];

    // 해당 ch가 opening이라면
    if (openingBrackets.indexOf(ch) > -1) {
      // temp에 추가
      temp.push(ch);

      // 해당 ch가 closing 이라면
    } else if (closingBrackets.indexOf(ch) > -1) {
      // 해당 ch를 map에서 closing으로 검색해서 나온 opening을 할당
      let expectedBracket = bracketsMap.get(ch);
      // 만약 temp에 opening이 없고 제일
      // 최근에 찾아 넣은 opening과 (현재) closing ch가 동일한 스타일이 아니라면
      // 다르면 (} 이렇게 쓴 것 일 테니까
      if (temp.length === 0 || temp.pop() !== expectedBracket) {
        return false;
      }
    } else {
      // opening도 closing도 아니면 넘어가기
      continue;
    }
  }

  // for loop을 다돌았을 때 temp가 비어있다면
  // === closing일때 temp를 다 빼갔으므로 짝이 있다면
  // true 반환
  // 짝이 없어서 opening이 남았다면 false로 반환
  return temp.length === 0;
}

var i1 = ['{}[]()', '{[}]'];

var i2 = [
  '{[}]',
  '[{()()}({[]})]({}[({})])((((((()[])){}))[]{{{({({({{{{{{}}}}}})})})}}}))[][][]',
  '{}[]()',
];

console.log(braces(i1)); // ["YES","NO"]
console.log(braces(i2)); // ["NO","YES","YES"]
```

#### 방법3. object 이용

이게 더 간단하고 읽기에도 쉬운 좋은 솔루션 같다 🤔

```js
function isBalanced(str) {
  let bracket = {
    '{': '}',
    '(': ')',
    '[': ']',
  };

  let heap = [];
  for (let char of str) {
    // if opening : closing 쌍이 존재한다면
    if (bracket[char]) {
      // closing을 haep에 넣기
      heap.push(bracket[char]);

      // opening이 아니라면 === closing이라면
    } else {
      if (heap.pop() !== char) return false;
    }
  }
  return !heap.length;
}

var i1 = '{}[]';

console.log(isBalanced(i1));
```

## 문제 54: 연속되는 수

숫자의 열이 연속되는 수인지 아닌지 확인할 것

### 내가 품

뭔가 좀 그래 🤔

```js
function numbersToGoing(str) {
  let array = str.split(' ').map((str) => parseInt(str, 10));

  for (let i = 0; i < array.length; i++) {
    if (array[i] < array[i + 1]) {
      let left = array[i];
      let right = array[i + 1];

      if (right !== left + 1) {
        return false;
      }
    } else if ((i = array.length - 1)) {
      return true;
    } else {
      return false;
    }
  }
}

var i1 = '1 2 3 4 5';

console.log(numbersToGoing(i1)); // ["YES","NO"]
```

### 답안

```js
function isBalanced(str) {
  let array = str.split(' ').map((str) => parseInt(str, 10));

  // 마지막 시도는 어짜피 그 앞단에서 해결하니까 -1로 해결
  for (let i = 0; i < array.length - 1; i++) {
    // false부터 적는게 빠른건데 ㅠ 아쉽다!
    if (array[i] + 1 !== array[i + 1]) {
      return 'NO';
    }
  }
  return 'Yes';
}

var i1 = '1 2 3 4 5';

console.log(isBalanced(i1)); // ["YES","NO"]
```

## 문제 55. 하노이의 탑

```js
function hanoi(num, start, end, temp) {
  return Math.pow(2, num) - 1;
}

console.log(hanoi(3, 'A', 'B', 'C'));
```

수학공식 이용해~~ 소리질러~~~ 💃

### 해답?

```js
let route = 0;

function stepsToSolveHanoiT(height, srcP, desP, bufferP) {
  if (height >= 1) {
    // Move a tower of height-1 to the buffer peg, using the destination peg.
    stepsToSolveHanoiT(height - 1, srcP, bufferP, desP);

    // Move the remaining disk to the destination peg.
    console.log('Move disk from Tower ', srcP, ' to Tower ', desP);
    route += 1;
    // Move the tower of `height-1` from the `buffer peg` to the `destination peg` using the `source peg`.
    stepsToSolveHanoiT(height - 1, bufferP, desP, srcP);
  }

  return route;
}

console.log(stepsToSolveHanoiT(5, 'A', 'C', 'B'));
```
